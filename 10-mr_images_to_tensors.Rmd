---
title: "Convert Images to Tensors"
date: "17.11.2020"
output: github_document
---

*NOTE:* Use these functions `ANTsRNet::resampleTensor`, `reticulate::array_reshape`

```{r, include = FALSE, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/10_images_to_tensors-",
  out.width = "100%"
)

`%>%` <- purrr::`%>%`

library(tidyverse, warn.conflicts = FALSE)
library(ANTsRCore)

library(devtools)
library(fs)

library(rraysplot)
packageVersion("rraysplot")
```


## Image data for U-Net

Source [2.2.11 Data representations for neural networks](https://livebook.manning.com/book/deep-learning-with-r/chapter-2/48)
in [Deep Learning with R](https://www.manning.com/books/deep-learning-with-r)
by François Chollet with J. J. Allaire.

Images typically have three dimensions:
```
height × width × color channels
```
Although grayscale images have only a single color channel 
and could thus be stored in 2D tensors, by convention 
image tensors are always 3D, with a one-dimensional color channel
for grayscale images. 

A batch of 80 grayscale images of size 768×384 could thus
be stored in a tensor of shape 
```
(80, 768, 384, 1)
```
and a batch of 80 color images could be stored in a tensor of shape
```
(80, 768, 384, 3)
```
and a batch of 80 mask --
```
(80, 768, 384, 2)
```


## Important Note

We will crop all images to 768x384 and prepare additional
data with resampled (smaller) images: 384x192 and 192x96.
Note that both dimensions 768x384 are divisble by 128
(768/2^7=6, 384/2^7=3).


## Helper functions

```{r}
crop_image_wxhx1 <- function(img, ll = c(0, 0), wh = c(768, 384)) {
  ll = c(ll, 1)
  # c(34, 56, 1)
  ur = ll + c(wh, 0) - c(1, 1, 0)
  # c(768 - 1, 384 - 1, 0)
  ANTsRCore::cropIndices(img, ll, ur)
}
```

```{r}
get_channel <- function(img, channel = 1) {
  ANTsRCore::splitChannels(img)[[channel]]
}
```

```{r}
imageList2sliceList <- function(
    iList,
    channel = 1,
    z_slice = 1,
    do_cropping = TRUE,
    lower_left = c(34, 56), 
    width_x_height = c(768, 384)
) {
  if (do_cropping == TRUE) {
    iList <- purrr::map(
      iList,
      crop_image_wxhx1, ll = lower_left, wh = width_x_height
    )
  }
  iList <- purrr::map(iList, get_channel, ch = channel)
  iList <- purrr::map(
    iList, 
    ANTsRCore::extractSlice, slice = z_slice, direction = 3
  ) 
}
```

```{r}
imageList2MaskList <- function(iList, clean_up = 2) {
  purrr::map(iList, ANTsRCore::getMask, cleanup = clean_up)
}
```


## Read Images Info

```{r}
info <- images_info("../80_images", extension = "dcm")
```

```{r, rows.print=2}
info_mri <- info %>% filter(kind == "MRI")
info_mri
```

```{r, rows.print=2}
info_scat <- info %>% filter(kind == "SCAT")
info_scat
```

```{r, rows.print=2}
info_vsat <- info %>% filter(kind == "VSAT")
info_vsat
```

## Create Images and Mask Lists

```{r}
mri_list  <- imageFileNames2ImageList(info_mri[["file_path"]]) %>%
  imageList2sliceList(channel = 1)
mask_list <- imageList2MaskList(mri_list, clean_up = 2)

scat_list <- imageFileNames2ImageList(info_scat[["file_path"]]) %>%
  imageList2sliceList(channel = 1)
vsat_list <- imageFileNames2ImageList(info_vsat[["file_path"]]) %>%
  imageList2sliceList(channel = 3)
```

```{r}
testthat::expect_equal(length(mri_list), 80)
testthat::expect_equal(length(mask_list), 80)
testthat::expect_equal(length(scat_list), 80)
testthat::expect_equal(length(vsat_list), 80)
```


## [Alpha blending](https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending_)

If the destination background is opaque, $\text{image}_A = 1$:
$$
\text{blended image}_{\rm RGB} = 
   (1 - \alpha)\cdot \text{image}_{\rm RGB} + 
      \alpha\cdot\text{mask}_{\rm RGB}
$$

### Blending antsImages

```{r}
i = 2
alpha = 0.25
# alpha == 0  # transparent mask
# alpha == 1  # opaque mask

mri <- mri_list[[i]]
mask <- mask_list[[i]]

mask[mask == 0] <- NA

class(mri)
range(mri)
unique(mask)

mri <- mri * mask
mrv <- as.numeric(mri/255)
mv <- as.numeric(mask)

class(mrv)

image_RGB <- colorspace::RGB(R = mrv, G = mrv, B = mrv)
mask_RGB <- colorspace::RGB(R = mv, G = mv, B = 0)

# (1 - alpha) * image_RGB + alpha * mask_RGB
out_RGB <- colorspace::mixcolor(alpha, image_RGB, mask_RGB)
out_hex <- colorspace::hex(out_RGB)
```

```{r eval=FALSE, include=FALSE}
# Neon Rainbow
# https://www.schemecolor.com/neon-rainbow.php
```

```{r}
d <- dim(mask)

dt <- tibble::tibble(
  y = rev(rep(1:d[2], each = d[1])),
  x = rep(1:d[1], times = d[2])
) %>%
  dplyr::mutate(z = out_hex)

dt %>% ggplot2::ggplot(ggplot2::aes(x, y)) +
    ggplot2::geom_raster(aes(fill = out_hex)) +
    ggplot2::labs(
      title = "colorspace",
      x = NULL,
      y = NULL
    ) +
    ggplot2::scale_fill_manual(
      values = as.character(levels(factor(out_hex))),
      na.value="#8B00FB"
    ) +
    # remove gray panel from the background
    ggplot2::coord_fixed(1, expand = FALSE) +
    ggplot2::theme(
      axis.ticks = ggplot2::element_blank(),
      axis.text = ggplot2::element_blank(),
      plot.title = ggplot2::element_text(
        margin = ggplot2::margin(t = 8, b = 16), # see ?margin
        size = 18,
        lineheight = 1,
        face = "bold",
        colour = "#3700FB",
        hjust = 0.5
      ),
      legend.position = "none"
    )
```


# Images Lists to Tensors

```{r}
i = 53

mask <- mask_list[[i]]
mask[mask == 0] <- NA

mri <- mri_list[[i]] * mask
scat <- scat_list[[i]] * mask
vsat <- vsat_list[[i]] * mask
```

```{r}
imageList2arrayList <- function(iList) {
  purrr::map(iList, as.array)
}
```

```{r}
mask_alist <- imageList2arrayList(mask_list)
mri_alist <- imageList2arrayList(mri_list)
scat_alist <- imageList2arrayList(scat_list)
vsat_alist <- imageList2arrayList(vsat_list)
```

```{r}
class(mri_alist[[53]])
```


```{r}
arrayList2Tensor <- function(aList, dim_names = info_mri$patient) {
  n_images <- length(aList)
  dims = dim(aList[[1]])

  y_train <- array(
    data = NA,
    dim = c(n_images, dims)
  )

  for (i in seq_along(aList)) {
    y_train[i,,] <- aList[[i]]
  }

  dimnames(y_train)[[1]] <- dim_names

  y_train
}
```


```{r}
mri_train <- arrayList2Tensor(mri_alist)
str(mri_train)

mask_train <- arrayList2Tensor(mask_alist)

# mask_train[mask_train == 0] <- NA
# mri_train <- mri_train * mask_train
```

```{r}
scat_train <- arrayList2Tensor(scat_alist)
# scat_train <- scat_train * mask_train
```

```{r}
vsat_train <- arrayList2Tensor(vsat_alist)
# vsat_train <- vsat_train * mask_train
```


### Check if dimnames are parallel to image indexes

```{r figures2-side2, fig.show="hold", fig.asp=0.5, out.width="48%"}
plot_array2d(mri_train[5,,], title = dimnames(mri_train)[[1]][[5]])
plot_array2d(mri_train[29,,], title = dimnames(mri_train)[[1]][[29]])
```

```{r figures2-side3, fig.show="hold", fig.asp=0.5, out.width="48%"}
plot_array2d(scat_train[46,,], title = dimnames(scat_train)[[1]][[46]])
plot_array2d(scat_train["700120",,], title = dimnames(scat_train)[[1]][[46]])
```

```{r figures2-side3, fig.show="hold", fig.asp=0.5, out.width="48%"}
plot_array2d(vsat_train[51,,], title = dimnames(vsat_train)[[1]][[51]])
plot_array2d(vsat_train[53,,], title = dimnames(vsat_train)[[1]][[53]])
```

```{r}
dim(vsat_train[53,,])
table(vsat_train[53,,])
```

Possible BUG: 	
Removed 211608 rows containing missing values (geom_raster).

```{r}
# plot_array2d(vsat_train[53,,])
plot_array2d(vsat_train[53,,] * mask_train[53,,])
```

```{r}
table(as.numeric(mask_train[53,,]), exclude = NULL)
```

```{r}
prod(dim(mask_train[53,,]))
83304+211608
```

```{r}
mask53 <- getMask(mri_list[[53]])
invisible(plot(mri_list[[53]], mask53, alpha = 0.4, doCropping = FALSE))
range(mask53)
```

```{r}
plot_array2d(mri_train[53,,])
```



```{r}
dims <- dim(vsat_train[53,,])

vec <- as.numeric(vsat_train[53,,])
length(vec[is.nan(vec)])
vec[is.nan(vec)] <- 0
range(vec)

vsat_train[53,,] <- array(vec, dim = dims) 
maxi = max(vsat_train[53,,], na.rm = TRUE)
maxi

plot_array2d(vsat_train[53,,])
# plot_array2d(vsat_train[54,,])
# plot_array2d(vsat_train[59,,])

# vsat[53,,][is.nan(vsat[53,,])] <- NA
# vsat[53,,] <- vsat[53,,] / maxi
# is.nan(maxi)
# is.na(maxi)
# maxi == 0
```



